

js里函数调用有4种模式：方法调用，正常函数调用，构造器调用，apply/call调用。

同时，无论哪种函数调用除了你声明时定义的形参外，还会自动添加2个形参，分别是this和arguments。

这里你既然问this，那么就只谈this。this的值，在上面4种调用模式下，分别会绑定不同的值。分别来说一说：



**方法调用**

这个很好理解，函数是一个对象的属性，比如：

```
var a = {
    v: 0,
    f: function(xx){
        this.v = xx;
    }
}
```

这个时候，上面函数里的this就绑定的是这个对象a。所以this.v可以取到对象a的属性v。

**正常函数调用**

```
function f(xx){
    this.x == xx;
}
f(5);
```

这个时候，函数f里的this绑定的是全局对象，如果是在浏览器运行的解释器，一般来说是楼上说的window对象。所以这里this.x访问的其实是window.x。当然，如果window没有x属性，那么你这么一写，按照js的坑爹语法，就是给window对象添加了一个x属性，同时赋值。

**构造器函数调用**

构造函数一直是我认为是js里最坑爹的部分，因为它和js最初设计的基于原型的面向对象实现方式格格不入，就好像是特意为了迎合大家已经被其他基于类的面向对象实现给惯坏了的习惯。

如果你在一个函数前面带上new关键字来调用，那么js会创建一个prototype属性是此函数的一个新对象，同时在调用这个函数的时候，把this绑定到这个新的对象上。当然new关键字也会改变return语句的行为，不过这里就不谈了。看代码

```
function a(xx){
    this.m = xx;
}
var b = new a(5);
```

上面这个函数和正常调用的函数定法上没有什么区别，只不过在调用的时候函数名前面加了关键字new罢了，这么一来，this绑定的就不再是前面讲的全局对象了，而是这里说的创建的新对象，所以说这种方式其实很危险，因为光看函数，你不会知道这个函数到底是准备拿来当构造函数用的，还是一般函数用的，所以我们可以看到，在jslint里，它会要求你写的所有构造函数首字母大写，也就是一旦它发现你用了new 关键字，那么后面那个函数的首字母必须大写，这样通过函数首字母大写的方式来区分，我个人只有一个看法：坑爹



**apply/call调用**

我们知道，在js里，函数其实也是一个对象，那么函数自然也可以拥有它自己的方法，有点绕，就好像函数可以自己有属性也是一个函数。其中每个函数都拥有apply\(\)这个方法，让我们构造一个参数数组传递给函数，同时可以自己来设置this的值，这就是它最强大的地方，上面的3种函数调用方法，你可以看到，this都是自动绑定的，没办法由你来设，当你想设的时候，就可以用apply\(\)了。apply接收2个参数，第一个是将传递给这个函数的this的值，第二个是参数数组。看代码：

```
function a(xx) {
    this.b = xx;
}
var o = {};
a.apply(o, [5]);
alert(a.b);    // undefined
alert(o.b);    // 5
```

是不是很神奇，函数a居然可以给o加属性值。当然，如果你apply的第一个参数传递null，那么在函数a里面this指针依然会绑定全局对象。你可能要问了，apply函数是哪来的，因为在js里所有的函数都有一个共同的prototype，也就是传说中的Function.prototype, 这个原型里有两个神奇的方法，一个就是这里的apply，另一个就是让题主疑惑的call。



说了这么一大堆，终于来到call了。call\(\)方法和apply\(\)方法很类似，它们的存在都是为了改变this的绑定，那call\(\)和apply\(\)有什么区别呢？就我个人看来，没啥鸟区别... 开玩笑！刚刚说了，上面apply\(\)接收两个参数，第一个是你想要this绑定的对象，第二个是一个参数数组，注意是一个数组，你想传递给这个函数的所有内容都放在数组里，然后apply\(\)函数会在传递形参时自动帮你展开，同时加入我们上面提到的另一个神奇形参argument。而call\(\)呢，它的第一个参数也是你想要this绑定的对象，但是后面可以接受不定参数，而不再是一个数组，也就是你可以像平时给函数传参那样把这些参数一个一个传递，当然，神奇形参arguments还是不会少的。所以如果一定要说有什么区别的话，看起来是这样的

```
function a(xx, yy) {
    alert(xx, yy);
    alert(this);
    alert(arguments);
}
a.apply(null, [5, 55]);
a.call(null, 5, 55);
```



